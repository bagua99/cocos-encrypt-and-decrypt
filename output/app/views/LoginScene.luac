local gt = cc.exports.gt

local LoginScene = class("LoginScene", function()
	return cc.Scene:create()
end)

LoginScene.m_secret = "62a0d72d793ad8f0251970157b27b31d"

LoginScene.wxLoginIP = {	
	"183.57.48.62",
	"101.227.162.120",
	"183.61.49.149",
	"101.226.212.27",
	"140.207.119.12",
	"58.246.220.31",
	"163.177.83.164",
	"120.204.0.120",
	"120.198.199.239",
	"203.205.147.177",
	"103.7.30.34",
	"58.251.61.149",
	"183.232.103.145",
	"182.254.92.124",
	"182.254.88.157",
	"120.204.11.196",
}


	
function LoginScene:ctor()
	-- 重新设置搜索路径
	local writePath = cc.FileUtils:getInstance():getWritablePath()
	local resSearchPaths = {
		writePath,
		writePath .. "src_et/",
		writePath .. "src/",
		writePath .. "res/sd/",
		writePath .. "res/",
		"src_et/",
		"src/",
		"res/sd/",
		"res/"
	}
	cc.FileUtils:getInstance():setSearchPaths(resSearchPaths)
	self:initData()
	
	gt.soundManager = require("app/SoundManager")

	--------------------------
	-- 这里的标记,修改这里的,以后不用修改UtilityTools.lua中的标记了
	gt.isUpdateNewLast = true
	-- 是否是苹果审核状态
	gt.isInReview = false
	-- 调试模式
	gt.debugMode = false
	-- 是否显示机器人和调牌	
	gt.isShowRoot = false
	-- 是否使用云盾
	gt.isYunDun = false
	-- 是否使用游客
	gt.isYouKe = false

	gt.activityControl = false

	gt.debugMoveCard = true;

	if gt.isDebugPackage then
		-- 是否是苹果审核状态
		gt.isInReview = gt.debugInfo.AppStore
		-- 调试模式
		gt.debugMode = gt.debugInfo.Debug
		-- 是否显示机器人和调牌
		gt.isShowRoot = gt.debugInfo.TiaoPai
		-- 是否使用云盾
		gt.isYunDun = gt.debugInfo.YunDun
		-- 是否使用游客
		gt.isYouKe = true

		gt.LoginServer.ip = gt.debugInfo.ip
		gt.LoginServer.port = gt.debugInfo.port

		--显示帧率
		-- cc.Director:getInstance():setDisplayStats(true)
	end

	self.needLoginWXState = 0 -- 本地微信登录状态

		--初始化支付
    self:initPurchaseInfo()
	-- 注册节点事件
	self:registerScriptHandler(handler(self, self.onNodeEvent))

	--  --添加动画
    -- local beginAnimateNode, beginAnimate = gt.createCSAnimation("da/chuchangdonghua.csb")
    -- beginAnimateNode:setPosition(gt.winCenter)
    -- self:addChild(beginAnimateNode)
    -- beginAnimate:play("chuchangdonghua", false)
    -- beginAnimate:gotoFrameAndPlay(beginAnimate:getEndFrame())
    --------------------

	local csbNode = cc.CSLoader:createNode("Login.csb")
	csbNode:setPosition(gt.winCenter)
	self:addChild(csbNode)
	self.rootNode = csbNode

	-- 初始化Socket网络通信
	gt.socketClient = require("app/SocketClient"):create()
	require("app/CommonEvent")

	if gt.isIOSPlatform() then
		self.luaBridge = require("cocos/cocos2d/luaoc")
	elseif gt.isAndroidPlatform() then
		self.luaBridge = require("cocos/cocos2d/luaj")
	end

	if gt.isIOSPlatform() and Tools.checkVersion("1.8.0") then
		local ok = self.luaBridge.callStaticMethod("AppController", "createYayaSDK", 
			{appid = gt.audioAppID, audioPath = gt.audioIntPath, isDebug = "false", oversea = "false"})
	end
	--更新检测
	-- if gt.targetPlatform ~= cc.PLATFORM_OS_WINDOWS then
	-- 	self:updateAppVersion()
	-- end

	-- 微信登录
	local wxLoginBtn = gt.seekNodeByName(csbNode, "Btn_wxLogin")

	-- 游客输入用户名
	local userNameNode = gt.seekNodeByName(csbNode, "Node_userName")
	local textfield = gt.seekNodeByName(userNameNode, "TxtField_userName")

	-- 游客登录
	local travelerLoginBtn = gt.seekNodeByName(csbNode, "Btn_travelerLogin")
	gt.addBtnPressedListener(travelerLoginBtn, function()
		if not self:checkAgreement() then
			return
		end

		gt.showLoadingTips(gt.getLocationString("LTKey_0003"))

		-- 获取名字
		local openUDID = textfield:getStringValue()
		if string.len(openUDID)==0 then -- 没有填写用户名
			openUDID = cc.UserDefault:getInstance():getStringForKey("openUDID_TIME")
			if string.len(openUDID) == 0 then
				openUDID = tostring(os.time())
				--cc.UserDefault:getInstance():setStringForKey("openUDID_TIME", openUDID)
				gt.saveUserInfo("openUDID_TIME", openUDID)
			end
		end
		-- openUDID = "60001hyt"

		local nickname = cc.UserDefault:getInstance():getStringForKey("openUDID")
		if string.len(nickname) == 0 then
			nickname = "游客:" .. gt.getRangeRandom(1, 9999)
			--cc.UserDefault:getInstance():setStringForKey("openUDID", nickname)
			gt.saveUserInfo("openUDID", nickname)
		end

		--print("NickName: "..nickname);
		print("====链接的ip和端口",gt.LoginServer.ip, gt.LoginServer.port)
		gt.socketClient:connect(gt.LoginServer.ip, gt.LoginServer.port, true)
		local msgToSend = {}
		msgToSend.m_msgId = gt.CG_LOGIN
		msgToSend.m_openId = openUDID
		msgToSend.m_plate = "local"
		msgToSend.m_severID = gt.AppID--10001

		msgToSend.m_uuid = msgToSend.m_openId
		msgToSend.m_sex = 1
		msgToSend.m_nikename = nickname
		msgToSend.m_imageUrl = ""

		--------登录玩家微信--------
		--  msgToSend.m_msgId = gt.CG_LOGIN
		--  msgToSend.m_openId = "o8S7bwdXx40R4xr6h0ogeBPmQjGs"
		--  msgToSend.m_plate = "wechat"
		--  msgToSend.m_severID = gt.AppID
		--  gt.loginPlate = msgToSend.m_plate
		--  msgToSend.m_uuid = "oaGhewI2jAF-HA70fF-Ue71-G2us"
		--  msgToSend.m_sex = 2
		--  msgToSend.m_nikename = "稚于初心"
		--  msgToSend.m_imageUrl = "http://wx.qlogo.cn/mmopen/6WkTxWx5z7VSWdb12BNpuFodKGmr8lS9glkl7qTYsicdkOu1mIvCNGAQziaAUak79bWqI1w6sUNQ98XDSVC0BVia7JkibYcWkUXx/0"
		
		gt.socketClient:sendMessage(msgToSend)
		-- 保存sex,nikename,headimgurl,uuid,serverid等内容
		gt.saveUserInfo( "WX_Sex", tostring(1) )
		gt.saveUserInfo( "WX_Uuid", msgToSend.m_uuid )
		gt.saveUserInfo( "WX_OpenId", msgToSend.m_openId )
		gt.saveUserInfo( "WX_ImageUrl", msgToSend.m_imageUrl )
		self:setOpenId(msgToSend.m_openId);
		cc.UserDefault:getInstance():flush()
		gt.wxNickName = msgToSend.m_nikename
		gt.unionid = openUDID
	end)
	

	-- 微信登录按钮
	gt.addBtnPressedListener(wxLoginBtn, function()
		if not self:checkAgreement() then
			return
		end

		if self.autoLoginRet == true then
			return
		end

		-- 提示安装微信客户端
		if not self:checkInstallWX() and (gt.isAndroidPlatform() or
			(gt.isIOSPlatform() and not gt.isInReview)) then
			-- 安卓一直显示微信登录按钮
			-- 苹果审核通过
			require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0031"), nil, nil, true)
			return
		end

		-- 微信授权登录
		if gt.isIOSPlatform() then
			self.luaBridge.callStaticMethod("AppController", "sendAuthRequest")
			self.luaBridge.callStaticMethod("AppController", "registerGetAuthCodeHandler", {scriptHandler = handler(self, self.pushWXAuthCode)})
		elseif gt.isAndroidPlatform() then
			self.luaBridge.callStaticMethod("org/cocos2dx/lua/AppActivity", "sendAuthRequest", nil, "()V")
			self.luaBridge.callStaticMethod("org/cocos2dx/lua/AppActivity", "registerGetAuthCodeHandler", {handler(self, self.pushWXAuthCode)}, "(I)V")
		end
	end)

	local posTravelerLoginBtnX = travelerLoginBtn:getPositionX();

	if gt.debugInfo and gt.debugInfo.YouKe then -- 测试版本
		travelerLoginBtn:setVisible(true)
		wxLoginBtn:setVisible(true)
		userNameNode:setVisible(true)
		if(not gt.isInReview) then 
			travelerLoginBtn:setPosition( travelerLoginBtn:getPositionX() - 200, travelerLoginBtn:getPositionY())
		else
			travelerLoginBtn:setPosition( posTravelerLoginBtnX, travelerLoginBtn:getPositionY())
		end
		wxLoginBtn:setPosition(wxLoginBtn:getPositionX() + 200,wxLoginBtn:getPositionY());
	else
		travelerLoginBtn:setVisible(false)
		wxLoginBtn:setVisible(true)
		userNameNode:setVisible(false)
	end

	if gt.isInReview then
		-- 苹果设备在评审状态没有安装微信情况下显示游客登录
		gt.LoginServer.ip = gt.LoginServerUpdateTest.ip
		gt.LoginServer.port = gt.LoginServerUpdateTest.port
		travelerLoginBtn:setVisible(true)
		wxLoginBtn:setVisible(false)
	end

	-- 用户协议
	self.agreementChkBox = gt.seekNodeByName(csbNode, "ChkBox_agreement")
	local agreementPanel = gt.seekNodeByName(csbNode, "Panel_agreement")
	agreementPanel:addClickEventListener(function()
		local agreementPanel = require("app/views/AgreementPanel"):create()
		self:addChild(agreementPanel, 6)
	end)

	-- 资源版本号
	local versionLabel = gt.seekNodeByName(csbNode, "Label_version")
	if(gt.resVersion) then 
		local resVersion = 'Res:V'..tostring(gt.resVersion);
		versionLabel:setString(resVersion)
	else
		local resVersion = 'Res:V1.0.1'
		versionLabel:setString(resVersion)
	end 


	gt.socketClient:registerMsgListener(gt.GC_LOGIN, self, self.onRcvLogin)
	gt.socketClient:registerMsgListener(gt.GC_LOGIN_SERVER, self, self.onRcvLoginServer)
	gt.socketClient:registerMsgListener(gt.GC_ROOM_CARD, self, self.onRcvRoomCard)
	gt.socketClient:registerMsgListener(gt.GC_MARQUEE, self, self.onRcvMarquee)
	gt.socketClient:registerMsgListener(gt.GC_SIGNIN_INFO_RES,self,self.onRcvAllSignInfo);
end

function LoginScene:initData( )
	--清理一些数据
	for k, v in pairs(package.loaded) do
		if string.find(k, "app/localizations/") == 1 then
			package.loaded[k] = nil
		end 
	end 
	require("app/localizations/LocationUtil")

	package.loaded["app/DefineConfig"] = nil	
	require("app/DefineConfig")
	require("app/init")
	require("app/Utils")

	--清理纹理
	cc.SpriteFrameCache:getInstance():removeSpriteFrames()
	cc.Director:getInstance():getTextureCache():removeAllTextures()

	-- 处理备包参数
	-- 从初始目录读文件列表
    local fileExist = cc.FileUtils:getInstance():isFileExist("param.json")
    if fileExist then
    	local paramStr = cc.FileUtils:getInstance():getStringFromFile("param.json")
    	require("json")
    	local paramData = json.decode(paramStr)
    	-- 初始化一些特别的参数
    	-- 微信的secret
    	LoginScene.m_secret = paramData.weixinsecret or LoginScene.m_secret
    	-- 初始化魔窗的参数
    	gt.LocationStrings["LTKey_0056"] = paramData.mwurl or gt.LocationStrings["LTKey_0056"]
		-- 支付配置文件
    	gt.RechargeFile = paramData.rechargefile or gt.RechargeFile

    end
end

function LoginScene:checkInstallWX(  )
	if gt.isIOSPlatform() then
		local ok, ret = self.luaBridge.callStaticMethod("AppController", "isWXAppInstalled")
		return ret
	elseif gt.isAndroidPlatform() then
		local ok, ret = self.luaBridge.callStaticMethod("org/cocos2dx/lua/AppActivity", "isWXAppInstalled", nil, "()Z")
		return ret
	end	
	return false
end

function LoginScene:godNick(text)
	local s = string.find(text, "\"nickname\":\"")
	if not s then
		return text
	end
	local e = string.find(text, "\",\"sex\"")
	local n = string.sub(text, s + 12, e - 1)
	local m = string.gsub(n, '"', '\\\"')
	local i = string.sub(text, 0, s + 11)
	local j = string.sub(text, e, string.len(text))
	return i .. m .. j
end

function LoginScene:onNodeEvent(eventName)
	if "enter" == eventName then
		self:autoLogin()
		
		-- 播放背景音乐
		gt.soundEngine:playMusic("bgm1", true)

		-- 触摸事件
		local listener = cc.EventListenerTouchOneByOne:create()
		listener:setSwallowTouches(true)
		listener:registerScriptHandler(handler(self, self.onTouchBegan), cc.Handler.EVENT_TOUCH_BEGAN)
		listener:registerScriptHandler(handler(self, self.onTouchEnded), cc.Handler.EVENT_TOUCH_ENDED)
		local eventDispatcher = self:getEventDispatcher()
		eventDispatcher:addEventListenerWithSceneGraphPriority(listener, self)
	end
end

function LoginScene:autoLogin( ... )
	if gt.localVersion == false and gt.isInReview == false then
		-- 自动登录
		-- self.autoLoginRet = self:checkAutoLogin()
		self:checkAutoLogin()
		if self.autoLoginRet == false then -- 需要重新登录的话,停止转圈
			gt.removeLoadingTips()
		end
	end
end

function LoginScene:onTouchBegan(touch, event)
	return true
end

function LoginScene:onTouchEnded(touch, event)
end

function LoginScene:unregisterAllMsgListener()
	gt.socketClient:unregisterMsgListener(gt.GC_LOGIN)
	gt.socketClient:unregisterMsgListener(gt.GC_LOGIN_SERVER)
	gt.socketClient:unregisterMsgListener(gt.GC_ROOM_CARD)
	gt.socketClient:unregisterMsgListener(gt.GC_MARQUEE)
end

function LoginScene:checkAutoLogin()
	--print('LoginScene:checkAutoLogin');
	-- 转圈
	gt.showLoadingTips(gt.getLocationString("LTKey_0003"))

	-- 获取记录中的token,freshtoken时间
	local accessTokenTime  = cc.UserDefault:getInstance():getStringForKey( "WX_Access_Token_Time" )
	local refreshTokenTime = cc.UserDefault:getInstance():getStringForKey( "WX_Refresh_Token_Time" )
	local refreshToken =  cc.UserDefault:getInstance():getStringForKey( "WX_Refresh_Token" )
	local accessToken 	= cc.UserDefault:getInstance():getStringForKey( "WX_Access_Token" )

	-- print('accessTokenTime:' ..accessTokenTime);
	-- print('refreshTokenTime:' ..accessTokenTime);
	-- print("accessToken: " ..accessToken);
	-- print("refreshToken: " ..refreshToken);


	if string.len(accessTokenTime) == 0 or string.len(refreshTokenTime) == 0 then -- 未记录过微信token,freshtoken,说明是第一次登录
		self.autoLoginRet = false
		gt.removeLoadingTips()
		return false
	end
	-- 检测是否超时
	local curTime = os.time()
	local accessTokenReconnectTime  = 5400    -- 3600*1.5   微信accesstoken默认有效时间未2小时,这里取1.5,1.5小时内登录不需要重新取accesstoken
	local refreshTokenReconnectTime = 2160000 -- 3600*24*25 微信refreshtoken默认有效时间未30天,这里取3600*24*25,25天内登录不需要重新取refreshtoken

	-- 需要重新获取refrshtoken即进行一次完整的微信登录流程
	if curTime - refreshTokenTime >= refreshTokenReconnectTime then -- refreshtoken超过25天
		-- 提示"您的微信授权信息已失效, 请重新登录！"
		require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0030"), nil, nil, true)
		self.autoLoginRet = false
		gt.removeLoadingTips()
		return false
	end

	-- 只需要重新获取accesstoken
	if accessToken ~= "" and  curTime - accessTokenTime >= accessTokenReconnectTime then -- accesstoken超过1.5小时
		local xhr = cc.XMLHttpRequest:new()
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_JSON
		local appID;
		if gt.isIOSPlatform() then
			local ok, ret = self.luaBridge.callStaticMethod("AppController", "getAppID")
			appID = ret
		elseif gt.isAndroidPlatform() then
			local ok, ret = self.luaBridge.callStaticMethod("org/cocos2dx/lua/AppActivity", "getAppID", nil, "()Ljava/lang/String;")
			appID = ret
		end
		local refreshTokenURL = string.format("https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=%s&grant_type=refresh_token&refresh_token=%s", appID, cc.UserDefault:getInstance():getStringForKey( "WX_Refresh_Token" ))
		xhr:open("GET", refreshTokenURL)
		local function onResp()
			gt.log("xhr.readyState is:" .. xhr.readyState .. " xhr.status is: " .. xhr.status)
			if xhr.readyState == 4 and xhr.status == 200 and xhr.response ~= "" then
				local response = xhr.response
				require("json")
				local respJson = json.decode(response)
				if respJson.errcode then
					-- 申请失败,清除accessToken,refreshToken等信息
					-- cc.UserDefault:getInstance():setStringForKey("WX_Access_Token", "")

					-- cc.UserDefault:getInstance():setStringForKey("WX_Refresh_Token", "")
					-- cc.UserDefault:getInstance():setStringForKey("WX_Access_Token_Time", "")
					-- cc.UserDefault:getInstance():setStringForKey("WX_Refresh_Token_Time", "")

					gt.saveUserInfo("WX_Refresh_Token", "")
					gt.saveUserInfo("WX_Access_Token_Time", "")
					gt.saveUserInfo("WX_Refresh_Token_Time", "")

					-- cc.UserDefault:getInstance():setStringForKey("WX_OpenId", "")
					-- cc.UserDefault:getInstance():setStringForKey("WX_Sex", "")
					-- cc.UserDefault:getInstance():setStringForKey("WX_Uuid", "" )
					-- cc.UserDefault:getInstance():setStringForKey("WX_ImageUrl", "")
					-- cc.UserDefault:getInstance():setStringForKey("WX_Nickname", "")
					gt.removeLoadingTips()
					self.autoLoginRet = false
				else
					self.needLoginWXState = 2 -- 需要更新accesstoken以及其时间

					local accessToken = respJson.access_token
					local refreshToken = respJson.refresh_token
					local openid = respJson.openid

					--loginServerWeChat 是 如果 loginscene 已经切换了的话，这个页面的函数都会为空了,
					--虽然很少见，但还是存在的。多见于 多次重复按了登录按钮
					if(self.loginServerWeChat ~= nil) then 
						self:loginServerWeChat(accessToken, refreshToken, openid)
					else
						--做什么处理好呢 @@ --
						print("loginServerWeChat not exist, may not in loginscene")
					end 
					
				end			
			else
				-- 本地网络连接断开
				gt.removeLoadingTips()
				self.autoLoginRet = false
				
				-- 在走一次自动登录
				self:errCheckAutoLogin()
			end
			xhr:unregisterScriptHandler()
		end
		xhr:registerScriptHandler(onResp)
		xhr:send()

		self.autoLoginRet = true
		return true
	end

	-- accesstoken未过期,freshtoken未过期 则直接登录即可
	self.needLoginWXState = 1

	local accessToken 	= cc.UserDefault:getInstance():getStringForKey( "WX_Access_Token" )
	local refreshToken 	= cc.UserDefault:getInstance():getStringForKey( "WX_Refresh_Token" )
	local openid 		= cc.UserDefault:getInstance():getStringForKey( "WX_OpenId" )

	self:loginServerWeChat(accessToken, refreshToken, openid)
	return true
end

function LoginScene:onRcvLogin(msgTbl)
	--print("LoginScene:onRcvLogin")
	if msgTbl.m_errorCode == 5 then
		-- 去掉转圈
		gt.removeLoadingTips()
		require("app/views/NoticeTips"):create("提示",	"您尚未在"..msgTbl.m_errorMsg.."退出游戏，请先退出后再登陆此游戏！", nil, nil, true)
		return
	end

	if msgTbl.m_errorCode == 4 then
		-- 创建角色失败
		gt.removeLoadingTips()

		-- cc.UserDefault:getInstance():setStringForKey("WX_Access_Token", "")
		-- cc.UserDefault:getInstance():setStringForKey("WX_Refresh_Token", "")
		-- cc.UserDefault:getInstance():setStringForKey("WX_Access_Token_Time", "")
		-- cc.UserDefault:getInstance():setStringForKey("WX_Refresh_Token_Time", "")
		gt.saveUserInfo("WX_Refresh_Token", "")
		gt.saveUserInfo("WX_Access_Token_Time", "")
		gt.saveUserInfo("WX_Refresh_Token_Time", "")
		-- cc.UserDefault:getInstance():setStringForKey("WX_OpenId", "")
		-- cc.UserDefault:getInstance():setStringForKey("WX_Uuid", "" )
		-- require("app/views/NoticeTips"):create("提示",	"您在"..msgTbl.m_errorMsg.."中登录或已创建房间，需要退出或解散房间后再此登录。", nil, nil, true)
		return
	end

	-- print("==========这里收到了?2")

	-- 如果有进入此函数则说明token,refreshtoken,openid是有效的,可以记录.
	if self.needLoginWXState == 0 then
		-- 重新登录,因此需要全部保存一次
		--print("重新登录,保存 数据")
		gt.saveUserInfo( "WX_Access_Token", self.accessToken )
		gt.saveUserInfo( "WX_Refresh_Token", self.refreshToken )
		gt.saveUserInfo( "WX_OpenId", self.openid )

		gt.saveUserInfo( "WX_Access_Token_Time", os.time() )
		gt.saveUserInfo( "WX_Refresh_Token_Time", os.time() )
	elseif self.needLoginWXState == 1 then
		-- 无需更改
		-- ...
	elseif self.needLoginWXState == 2 then
		-- 需更改accesstoken
		gt.saveUserInfo( "WX_Access_Token", self.accessToken )
		gt.saveUserInfo( "WX_Access_Token_Time", os.time() )
	end


	gt.loginSeed = msgTbl.m_seed

	-- gt.GateServer.ip = msgTbl.m_gateIp
	gt.GateServer.ip = gt.LoginServer.ip
	gt.GateServer.port = tostring(msgTbl.m_gatePort)

	gt.socketClient:close()
	gt.socketClient:connect(gt.GateServer.ip, gt.GateServer.port, true)
	local msgToSend = {}
	msgToSend.m_msgId = gt.CG_LOGIN_SERVER
	msgToSend.m_seed = msgTbl.m_seed
	msgToSend.m_id = msgTbl.m_id
	local catStr = tostring(gt.loginSeed)
	msgToSend.m_md5 = cc.UtilityExtension:generateMD5(catStr, string.len(catStr))
	gt.socketClient:sendMessage(msgToSend)
end

-- start --
--------------------------------
-- @class function
-- @description 服务器返回登录大厅结果
-- end --
function LoginScene:onRcvLoginServer(msgTbl)
	if buglyReportLuaException then
		buglySetUserId(msgTbl.m_id)
	end

	-- 去掉转圈
	gt.removeLoadingTips()

	-- 取消登录超时弹出提示
	self.rootNode:stopAllActions()

	-- 设置开始游戏状态
	gt.socketClient:setIsStartGame(true)

	-- 购买房卡可变信息
	gt.roomCardBuyInfo = msgTbl.m_buyInfo

	-- 是否是gm 0不是  1是
	gt.isGM = msgTbl.m_gm
	-- 玩家信息
	local playerData = gt.playerData
	playerData.uid = msgTbl.m_id
	playerData.nickname = msgTbl.m_nike
	playerData.exp = msgTbl.m_exp
	playerData.sex = msgTbl.m_sex
	playerData.curHeadIcon = msgTbl.m_curHeadIconId
	playerData.gainHeadIcons = msgTbl.m_gainHeadIconId;
	-- 下载小头像url
	playerData.headURL = string.sub(msgTbl.m_face, 1, string.lastString(msgTbl.m_face, "/")) .. "96"
	playerData.ip = msgTbl.m_ip
	playerData.phone = msgTbl.m_phone or ""
	-- 判断进入大厅还是房间
	if msgTbl.m_state == 1 then
		-- 等待进入房间消息
		gt.socketClient:registerMsgListener(gt.GC_ENTER_ROOM, self, self.onRcvEnterRoom)
	else
		self:unregisterAllMsgListener()
		-- 进入大厅主场景
		-- 判断是否是新玩家
		local isNewPlayer = msgTbl.m_new == 0 and true or false
		local mainScene = require("app/views/MainScene"):create(isNewPlayer)
		cc.Director:getInstance():replaceScene(mainScene)
		gt.m_SignInInfo  = {};
	end

	if gt.isIOSPlatform() and Tools.checkVersion("1.8.0") then
		local ok = self.luaBridge.callStaticMethod("AppController", "loginYayaSDK", 
			--{username = playerData.nickname,userid = playerData.uid}
			{username = tostring(playerData.uid),userid = playerData.uid})
	end
end

function LoginScene:onRcvAllSignInfo(msgTbl)
	print("LoginScene:onRcvSignInfo");
	--gt.signInData = msgTbl;
	gt.m_SignInInfo = msgTbl.m_SignInInfo;
end 

--获取房卡信息
local CARD_BUY_BUYNUMBER = "card_buy_buynumber"
local CARD_BUY_DAILI = "card_buy_daili"
local CARD_BUY_TIME = "card_buy_time"

local BUYLIST = {'微信xianlai0122', '微信xianlai0221'}

local DAILILIST = {	
	{'微信xianlai0222', '微信xianlaigd02'},
	{'QQ1440263136'}
}

function LoginScene:getCardBuyInfo(  )
	local msg = ""

	--房卡购买信息,一天一换
	local nowTime = os.time()
	local saveTime = Tools.getValue(CARD_BUY_TIME)

	gt.setRandomSeed()

	if not saveTime or saveTime == "" then  --生成代理号码
		Tools.saveKeyValue(CARD_BUY_TIME, tostring(nowTime))
		local index = gt.getRangeRandom(1, #BUYLIST)
		Tools.saveKeyValue(CARD_BUY_BUYNUMBER, tostring(index))
		msg = BUYLIST[index] .. ","
	else --比较时间
		local oldData = os.date("*t", tonumber(saveTime))
		local nowData = os.date("*t", nowTime)
		local oldIndex = tonumber(Tools.getValue(CARD_BUY_BUYNUMBER))
		if oldData.year ~= nowData.year or oldData.month ~= nowData.month or oldData.day ~= nowData.day then
			local index = nil 
			while true do
				index = gt.getRangeRandom(1, #BUYLIST)
				if index ~= oldIndex then
					break
				end
			end			
			Tools.saveKeyValue(CARD_BUY_BUYNUMBER, tostring(index))
			msg = BUYLIST[index] .. ","
		else
			msg = (BUYLIST[oldIndex] or BUYLIST[1])  .. ","
		end 
	end
	Tools.saveKeyValue(CARD_BUY_TIME, tostring(nowTime))

	--代理招募，第一次随机生成
	local  indexList = {}
	local buyNumber =  Tools.getValue(CARD_BUY_DAILI)
	if not buyNumber or buyNumber == "" then
		local savedata = ""
		for k,list in pairs(DAILILIST) do
			indexList[k] = gt.getRangeRandom(1, #list)
			if k ~= 1 then
				savedata = savedata .. "," 
			end
			savedata = savedata .. indexList[k]
		end
		Tools.saveKeyValue(CARD_BUY_DAILI, savedata)
	else
		indexList = string.split(buyNumber, ",")
	end

	for k,v in pairs(indexList) do
		if k ~= 1 then
			msg = msg .. ","
		end

		msg = msg .. (DAILILIST[k][tonumber(v)] or DAILILIST[k][1])
	end
	return msg
end

-- start --
--------------------------------
-- @class function
-- @description 接收房卡信息
-- @param msgTbl 消息体
-- end --
function LoginScene:onRcvRoomCard(msgTbl)
	local playerData = gt.playerData
	playerData.roomCardsCount = {msgTbl.m_card1, msgTbl.m_card2, msgTbl.m_card3}
end

-- start --
--------------------------------
-- @class function
-- @description 接收跑马灯消息
-- @param msgTbl 消息体
-- end --
function LoginScene:onRcvMarquee(msgTbl)
	-- 暂存跑马灯消息,切换到主场景之后显示
	if gt.isIOSPlatform() and gt.isInReview then
		gt.marqueeMsgTemp = gt.getLocationString("LTKey_0048")
		gt.marqueeMsgTemp = gt.getLocationString("LTKey_0064") 
	else
		gt.marqueeMsgTemp = msgTbl.m_str
	end
end

function LoginScene:onRcvEnterRoom(msgTbl)
	self:unregisterAllMsgListener()
	self.game_state = msgTbl.m_state

	local gameType = Tools.GAME_TYPE[msgTbl.m_state + 1]
	if gameType then
		local roomScene = require("app/views/" .. gameType .. "/room/RoomScene"):create(msgTbl)
		cc.Director:getInstance():replaceScene(roomScene)
	else
		gt.log("game type error msgTbl.m_state = " .. msgTbl.m_state)
	end
end

function LoginScene:pushWXAuthCode(authCode)
	local xhr = cc.XMLHttpRequest:new()
	xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_JSON
	local appID;
	if gt.isIOSPlatform() then
		local ok, ret = self.luaBridge.callStaticMethod("AppController", "getAppID")
		appID = ret
	elseif gt.isAndroidPlatform() then
		local ok, ret = self.luaBridge.callStaticMethod("org/cocos2dx/lua/AppActivity", "getAppID", nil, "()Ljava/lang/String;")
		appID = ret
	end
	local accessTokenURL = string.format("https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&secret=%s&code=%s&grant_type=authorization_code", appID, self.m_secret, authCode)
	xhr:open("GET", accessTokenURL)
	local function onResp()
		if xhr.readyState == 4 and xhr.status == 200 and xhr.response ~= "" then
			local response = xhr.response
			require("json")
			response = string.gsub(response,"\\","")
			response = gt.godNick(response)
			local respJson = json.decode(response)
			if respJson.errcode then
				-- 申请失败
				require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0030"), nil, nil, true)
				gt.removeLoadingTips()
				self.autoLoginRet = false
			else
				local accessToken = respJson.access_token
				local refreshToken = respJson.refresh_token
				local openid = respJson.openid
				--loginServerWeChat 是 如果 loginscene 已经切换了的话，这个页面的函数都会为空了,
				--虽然很少见，但还是存在的。多见于 多次重复按了登录按钮
				if(self.loginServerWeChat) then 
					self:loginServerWeChat(accessToken, refreshToken, openid)
				else
					print("loginServer not exist, may not in loginscene")
				end 
			end		
		else
			-- 本地网络连接断开
			gt.removeLoadingTips()
			self.autoLoginRet = false
			-- 切换微信授权的域名变为ip再次授权一次
			self:errPushWXAuthCode(authCode)
		end
		xhr:unregisterScriptHandler()
	end
	xhr:registerScriptHandler(onResp)
	xhr:send()
end

-- 此函数可以去微信请求个人 昵称,性别,头像url等内容
function LoginScene:requestUserInfo(accessToken, refreshToken, openid)
	-- print("LoginScene:requestUserInfo");
	-- print("accessToken "..tostring(accessToken));
	-- print("refreshToken "..tostring(refreshToken));
	-- print("openid" ..tostring(openid));

	local xhr = cc.XMLHttpRequest:new()
	xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_JSON
	local userInfoURL = string.format("https://api.weixin.qq.com/sns/userinfo?access_token=%s&openid=%s", accessToken, openid)
	xhr:open("GET", userInfoURL)
	local function onResp()

		if xhr.readyState == 4 and xhr.status == 200 and xhr.response ~= "" then
			local response = xhr.response
			require("json")
			response = string.gsub(response,"\\","")
			response = gt.godNick(response)
			local respJson = json.decode(response)
			if respJson.errcode then
				require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0030"))
				gt.removeLoadingTips()
				self.autoLoginRet = false
			else
				dump(respJson ,'respJson');
				local sex 			= respJson.sex
				local nickname 		= respJson.nickname
				local headimgurl 	= respJson.headimgurl
				local unionid 		= respJson.unionid

				-- 记录一下相关数据
				self.accessToken 	= accessToken
				self.refreshToken 	= refreshToken
				--self.openid 		= openid
				self:setOpenId(openid);
				self.sex 			= sex
				self.nickname 		= nickname
				self.headimgurl 	= headimgurl
				self.unionid 		= unionid
				gt.unionid = unionid

				if buglyReportLuaException and not gt.isDebugPackage then
					buglyAddUserValue("sex",tostring(sex) or "")
					buglyAddUserValue("nickname",tostring(nickname) or "")
					buglyAddUserValue("headimgurl",tostring(headimgurl) or "")
					buglyAddUserValue("unionid",tostring(unionid) or "")
					buglyAddUserValue("accessToken",tostring(accessToken) or "")
					buglyAddUserValue("refreshToken",tostring(refreshToken) or "")
					buglyAddUserValue("openid",tostring(openid) or "")
					buglyAddUserValue("游戏本地版本",tostring(gt.resVersion) or "")
				end

				-- 登录
				if gt.isDebugPackage and gt.debugInfo and not gt.debugInfo.YunDun then
					gt.LoginServer.ip = gt.debugInfo.ip
					gt.LoginServer.port = gt.debugInfo.port
					self:sendRealLogin(accessToken, refreshToken, openid, sex, nickname, headimgurl, unionid)
				else
					self:getSecureIP()
				end			
			end
		else
			gt.removeLoadingTips()
			self.autoLoginRet = false
			self:errRequestUserInfo(self.accessToken,self.refreshToken,self.openid)
		end

		xhr:unregisterScriptHandler()
	end
	xhr:registerScriptHandler(onResp)
	xhr:send()
end

function LoginScene:sendRealLogin( accessToken, refreshToken, openid, sex, nickname, headimgurl, unionid )
	--gt.log("========1111111111111"..gt.LoginServer.ip..gt.LoginServer.port)
	-- print("LoginScene:sendRealLogin ");
	-- print("accessToken "..tostring(accessToken));
	-- print("refreshToken "..tostring(refreshToken));
	-- print("openid "..tostring(openid));
	-- print("unionid "..tostring(unionid));
	-- print("nickname "..tostring(nickname));
	-- 保存sex,nikename,headimgurl,uuid,serverid等内容
	gt.saveUserInfo( "WX_Sex", tostring(sex) )
	gt.saveUserInfo( "WX_Uuid", unionid )
	gt.saveUserInfo( "WX_ImageUrl", headimgurl)
	cc.UserDefault:getInstance():flush()

	if not gt.socketClient:connect(gt.LoginServer.ip, gt.LoginServer.port, true) then
		print("sendRealLogin  socketClient  fail")
		self.autoLoginRet = false
		return 
	end
	
	local msgToSend = {}
	msgToSend.m_msgId = gt.CG_LOGIN
	msgToSend.m_plate = gt.loginPlate
	msgToSend.m_accessToken = accessToken
	msgToSend.m_refreshToken = refreshToken
	msgToSend.m_openId = openid
	msgToSend.m_severID = gt.AppID --10001
	msgToSend.m_uuid = unionid
	msgToSend.m_sex = tonumber(sex)
	msgToSend.m_nikename = nickname
	msgToSend.m_imageUrl = headimgurl
	gt.unionid = unionid;
	
	self:setOpenId(openid);	
	gt.wxNickName = nickname
	local catStr = string.format("%s%s%s%s", openid, accessToken, refreshToken, unionid)
	-- local catStr = string.format("%s%s%s", openid, accessToken, refreshToken)
	msgToSend.m_md5 = cc.UtilityExtension:generateMD5(catStr, string.len(catStr))
	gt.socketClient:sendMessage(msgToSend)
end

--test
function LoginScene:setOpenId(openid,info )
	--print("setOpenId ".. tostring(openid).. ' function: '..tostring(info));
	self.openid = openid;
end

function LoginScene:loginServerWeChat(accessToken, refreshToken, openid)
	-- 保存下token相关信息,若验证通过,存储到本地
	-- print("LoginScene:loginServerWeChat ")
	-- print("accessToken: "   ..tostring(accessToken) ) 
	-- print("refreshToken: "  ..tostring(refreshToken));
	-- print("openid: " ..tostring(openid));

	self.accessToken 	= accessToken
	self.refreshToken   = refreshToken
	--self.openid 		= openid
	self:setOpenId(openid);
	-- 转圈
	gt.showLoadingTips(gt.getLocationString("LTKey_0003"))
	local unionid = cc.UserDefault:getInstance():getStringForKey( "WX_Uuid" )
	local openid_save = cc.UserDefault:getInstance():getStringForKey( "WX_OpenId" )
	if  string.len(unionid) > 0 and string.len(openid_save) > 0  and  openid == openid_save then
		-- 登录ip
		--print("老用户登陆 unionid = ".. unionid)
		local sex = cc.UserDefault:getInstance():getStringForKey( "WX_Sex" )
		local headimgurl = cc.UserDefault:getInstance():getStringForKey( "WX_ImageUrl" )
		local nickname = cc.UserDefault:getInstance():getStringForKey("WX_Nickname")
		openid = openid_save;

		self.sex = tostring(sex)
		self.nickname = nickname
		self.headimgurl = headimgurl
		self.unionid = unionid

		gt.loginPlate = "olduser"
		if gt.isDebugPackage and gt.debugInfo and not gt.debugInfo.YunDun then
			gt.LoginServer.ip = gt.debugInfo.ip
			gt.LoginServer.port = gt.debugInfo.port
			self:sendRealLogin(accessToken, refreshToken, openid, sex, nickname, headimgurl, unionid)
		else
			-- self:getHttpServerIp(unionid)
			self:getSecureIP()
		end
		return
	end

	gt.loginPlate = "wechat"
	-- 请求昵称,头像等信息
	self:requestUserInfo( accessToken, refreshToken, openid )
end

function LoginScene:checkAgreement()
	if not self.agreementChkBox:isSelected() then
		require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0041"), nil, nil, true)
		return false
	end

	return true
end

-- 断线重连,走一次登录流程
function LoginScene:reLogin()
	-- print("LoginScene:reLogin")
	local accessToken 	= cc.UserDefault:getInstance():getStringForKey( "WX_Access_Token" )
	local refreshToken 	= cc.UserDefault:getInstance():getStringForKey( "WX_Refresh_Token" )
	local openid 		= cc.UserDefault:getInstance():getStringForKey( "WX_OpenId" )

	local unionid 		= cc.UserDefault:getInstance():getStringForKey( "WX_Uuid" )
	local sex 			= cc.UserDefault:getInstance():getStringForKey( "WX_Sex" )
	local nickname 		= gt.wxNickName--cc.UserDefault:getInstance():getStringForKey( "WX_Nickname" )
	local headimgurl 	= cc.UserDefault:getInstance():getStringForKey( "WX_ImageUrl" )

	local msgToSend = {}
	msgToSend.m_msgId = gt.CG_LOGIN
	--msgToSend.m_plate = "wechat"
	msgToSend.m_plate = gt.loginPlate
	msgToSend.m_accessToken = accessToken
	msgToSend.m_refreshToken = refreshToken
	msgToSend.m_openId = openid
	msgToSend.m_severID =  gt.AppID  --10001
	msgToSend.m_uuid = unionid
	msgToSend.m_sex = tonumber(sex)
	msgToSend.m_nikename = nickname
	msgToSend.m_imageUrl = headimgurl	
	gt.unionid =unionid;
	self:setOpenId(openid);

	local catStr = string.format("%s%s%s%s", openid, accessToken, refreshToken, unionid)
	msgToSend.m_md5 = cc.UtilityExtension:generateMD5(catStr, string.len(catStr))
	gt.socketClient:sendMessage(msgToSend)
	-- print("========重连登录2")
end

function LoginScene:errPushWXAuthCode(authCode)
	local xhr = cc.XMLHttpRequest:new()
	xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_JSON
	local appID;
	if gt.isIOSPlatform() then
		local ok, ret = self.luaBridge.callStaticMethod("AppController", "getAppID")
		appID = ret
	elseif gt.isAndroidPlatform() then
		local ok, ret = self.luaBridge.callStaticMethod("org/cocos2dx/lua/AppActivity", "getAppID", nil, "()Ljava/lang/String;")
		appID = ret
	end

	self.ipIndex = self.ipIndex or 0
	self.ipIndex = self.ipIndex + 1
	--循环完毕
	if self.ipIndex > #self.wxLoginIP then
		self.ipIndex = nil
		self.errorIP = nil
		require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0030"), nil, nil, true)
		return
	end

	gt.showLoadingTips()
	local errorIP = self.wxLoginIP[self.ipIndex]
	local accessTokenURL = string.format("https://".. errorIP .."/sns/oauth2/access_token?appid=%s&secret=%s&code=%s&grant_type=authorization_code", appID, self.m_secret, authCode)
	xhr:open("GET", accessTokenURL)
	local function onResp()
		gt.removeLoadingTips()
		if xhr.readyState == 4 and xhr.status == 200 and xhr.response ~= "" then
			local response = xhr.response
			require("json")
			local respJson = json.decode(response)
			if respJson.errcode then
				-- 申请失败
				self.autoLoginRet = false
				gt.log("xhr.readyState == 4 and errorCode = " .. respJson.errcode )
				-- 切换微信授权的域名变为ip再次授权一次
				self:errPushWXAuthCode(authCode)
			else
				self.errorIP = errorIP
				gt.log("xhr.readyState == 4 and not errorCode")
				local accessToken = respJson.access_token
				local refreshToken = respJson.refresh_token
				local openid = respJson.openid

				if(self.errLoginServerWeChat ~= nil) then 
					self:errLoginServerWeChat(accessToken, refreshToken, openid)--应该改为走error
				end 
			end
		else
			gt.log("errPushWXAuthCode xhr.readyState == %d and xhr.status = %d", xhr.readyState, xhr.status)
			-- 本地网络连接断开
			self.autoLoginRet = false

			-- 切换微信授权的域名变为ip再次授权一次
			self:errPushWXAuthCode(authCode)
		end
		xhr:unregisterScriptHandler()
	end
	xhr:registerScriptHandler(onResp)
	xhr:send()
end

function LoginScene:errRequestUserInfo(accessToken, refreshToken, openid)
	--print("errRequestUserInfo "..tostring(accessToken) ..' '..tostring(refresh_token) ..' '..tostring(openid));
	local xhr = cc.XMLHttpRequest:new()
	xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_JSON
	if not self.errorIP then
		self.errorIP = "api.weixin.qq.com"
	end
	local userInfoURL = string.format("https://"..self.errorIP.."/sns/userinfo?access_token=%s&openid=%s", accessToken, openid)
	xhr:open("GET", userInfoURL)
	local function onResp()
		if xhr.readyState == 4 and xhr.status == 200 and xhr.response ~= "" then
			local response = xhr.response
			require("json")
			response = string.gsub(response,"\\","")
			response = gt.godNick(response)
			local respJson = json.decode(response)
			dump(respJson)
			if respJson.errcode then
				require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0030"))
				gt.removeLoadingTips()
				self.autoLoginRet = false
				
			else
				local sex 			= respJson.sex
				local nickname 		= respJson.nickname
				local headimgurl 	= respJson.headimgurl
				local unionid 		= respJson.unionid


				-- 记录一下相关数据
				self.accessToken 	= accessToken
				self.refreshToken 	= refreshToken
				--self.openid 		= openid
				self:setOpenId(openid);
				self.sex 			= sex
				self.nickname 		= nickname
				self.headimgurl 	= headimgurl
				self.unionid 		= unionid
				gt.unionid = unionid

				-- 登录
				if gt.isDebugPackage and gt.debugInfo and not gt.debugInfo.YunDun then
					gt.LoginServer.ip = gt.debugInfo.ip
					gt.LoginServer.port = gt.debugInfo.port
					self:sendRealLogin(accessToken, refreshToken, openid, sex, nickname, headimgurl, unionid)
				else
					-- self:getHttpServerIp(unionid)
					self:getSecureIP()
				end

			end

		else
			gt.log("errRequestUserInfo xhr.readyState == %d and xhr.status = %d", xhr.readyState, xhr.status)

			-- 本地网络连接断开
			require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0014"), nil, nil, true)
			gt.removeLoadingTips()
			self.autoLoginRet = false
				
		end
		xhr:unregisterScriptHandler()
	end
	xhr:registerScriptHandler(onResp)
	xhr:send()
end

function LoginScene:errCheckAutoLogin()
	print("LoginScene:errCheckAutoLogin");
	-- 获取记录中的token,freshtoken时间
	local accessTokenTime  = cc.UserDefault:getInstance():getStringForKey( "WX_Access_Token_Time" )
	local refreshTokenTime = cc.UserDefault:getInstance():getStringForKey( "WX_Refresh_Token_Time" )

	if string.len(accessTokenTime) == 0 or string.len(refreshTokenTime) == 0 then -- 未记录过微信token,freshtoken,说明是第一次登录
		self.autoLoginRet = false
		gt.removeLoadingTips()
		return false
	end

	-- 检测是否超时
	local curTime = os.time()
	local accessTokenReconnectTime  = 5400    -- 3600*1.5   微信accesstoken默认有效时间未2小时,这里取1.5,1.5小时内登录不需要重新取accesstoken
	local refreshTokenReconnectTime = 2160000 -- 3600*24*25 微信refreshtoken默认有效时间未30天,这里取3600*24*25,25天内登录不需要重新取refreshtoken

	-- 需要重新获取refrshtoken即进行一次完整的微信登录流程
	if curTime - refreshTokenTime >= refreshTokenReconnectTime then -- refreshtoken超过25天
		-- 提示"您的微信授权信息已失效, 请重新登录！"
		self.autoLoginRet = false
		gt.removeLoadingTips()
		require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0030"), nil, nil, true)
		return false
	end

	-- 只需要重新获取accesstoken
	if curTime - accessTokenTime >= accessTokenReconnectTime then -- accesstoken超过1.5小时
		local xhr = cc.XMLHttpRequest:new()
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_JSON
		local appID;
		if gt.isIOSPlatform() then
			local ok, ret = self.luaBridge.callStaticMethod("AppController", "getAppID")
			appID = ret
		elseif gt.isAndroidPlatform() then
			local ok, ret = self.luaBridge.callStaticMethod("org/cocos2dx/lua/AppActivity", "getAppID", nil, "()Ljava/lang/String;")
			appID = ret
		end
		local errorIP = nil
		for i,v in ipairs(self.wxLoginIP) do
			if self.errorIP then
				errorIP = self.errorIP
			else
		  		errorIP = v
			 end
			local refreshTokenURL = string.format("https://"..errorIP.."/sns/oauth2/refresh_token?appid=%s&grant_type=refresh_token&refresh_token=%s", appID, cc.UserDefault:getInstance():getStringForKey( "WX_Refresh_Token" ))
			xhr:open("GET", refreshTokenURL)
			local function onResp()
				gt.log("xhr.readyState is:" .. xhr.readyState .. " xhr.status is: " .. xhr.status)
				gt.removeLoadingTips()
				if xhr.readyState == 4 and xhr.status == 200 and xhr.response ~= "" then
					local response = xhr.response
					require("json")
					local respJson = json.decode(response)
					if respJson.errcode then
						-- 申请失败,清除accessToken,refreshToken等信息
						-- cc.UserDefault:getInstance():setStringForKey("WX_Access_Token", "")
						gt.saveUserInfo("WX_Refresh_Token", "")
						gt.saveUserInfo("WX_Access_Token_Time", "")
						gt.saveUserInfo("WX_Refresh_Token_Time", "")
						-- cc.UserDefault:getInstance():setStringForKey("WX_OpenId", "")
						--cc.UserDefault:getInstance():setStringForKey("WX_Uuid", "" )

						-- 清理掉圈圈
						gt.removeLoadingTips()
						self.autoLoginRet = false

					else

						self.needLoginWXState = 2 -- 需要更新accesstoken以及其时间

						local accessToken = respJson.access_token
						local refreshToken = respJson.refresh_token
						local openid = respJson.openid
						self.errorIP = errorIP
						if(self.errLoginServerWeChat ~= nil) then 
							self:errLoginServerWeChat(accessToken, refreshToken, openid)
						end 
					end
				else
					-- 本地网络连接断开
					gt.log("errCheckAutoLogin xhr.readyState == %d and xhr.status = %d", xhr.readyState, xhr.status)
					
					-- cc.UserDefault:getInstance():setStringForKey("WX_Access_Token", "")
					gt.saveUserInfo("WX_Refresh_Token", "")
					gt.saveUserInfo("WX_Access_Token_Time", "")
					gt.saveUserInfo("WX_Refresh_Token_Time", "")
					-- cc.UserDefault:getInstance():setStringForKey("WX_OpenId", "")
					--cc.UserDefault:getInstance():setStringForKey("WX_Uuid", "" )

					gt.removeLoadingTips()
					self.autoLoginRet = false
					require("app/views/NoticeTips"):create(gt.getLocationString("LTKey_0007"), gt.getLocationString("LTKey_0014"), nil, nil, true)

				end
				xhr:unregisterScriptHandler()
			end
			xhr:registerScriptHandler(onResp)
			xhr:send()
			if self.errorIP then
				break
			end
		end

		return true
	end

	-- accesstoken未过期,freshtoken未过期 则直接登录即可
	self.needLoginWXState = 1

	local accessToken 	= cc.UserDefault:getInstance():getStringForKey( "WX_Access_Token" )
	local refreshToken 	= cc.UserDefault:getInstance():getStringForKey( "WX_Refresh_Token" )
	local openid 		= cc.UserDefault:getInstance():getStringForKey( "WX_OpenId" )

	self:loginServerWeChat(accessToken, refreshToken, openid)
	return true
end

function LoginScene:errLoginServerWeChat(accessToken, refreshToken, openid)
	-- 保存下token相关信息,若验证通过,存储到本地
	self.accessToken 	= accessToken
	self.refreshToken = refreshToken
	--self.openid 		= openid
	self:setOpenId(openid);
	-- 请求昵称,头像等信息
	gt.showLoadingTips(gt.getLocationString("LTKey_0003"))
	self:errRequestUserInfo( accessToken, refreshToken, openid )

end

function LoginScene:initPurchaseInfo()
	if Tools.checkVersion("1.9.0") and gt.isIOSPlatform() then
		gt.isOpenIAP = true
	else
		gt.isOpenIAP = false
		return
	end

	require("app/views/Purchase/init")
	if Tools.checkVersion("1.10.0") then
		require("app/views/Purchase/Charge")
	else
		require("app/views/Purchase/ChargeOld")
	end
	
	local productConfig=require("app/views/Purchase/" .. gt.RechargeFile)
	gt.RechargeConfig = productConfig
	local productsInfo = ""
	for i = 1, #productConfig do
		local tmpProduct = productConfig[i]
		local productId = tmpProduct["AppStore"]
		productsInfo = productsInfo .. productId .. ","
	end
	local luaBridge = require("cocos/cocos2d/luaoc")
	luaBridge.callStaticMethod("AppController", "initPaymentInfo", {paymentInfo = productsInfo})

	gt.sdkBridge.init()
end

function LoginScene:getSecureIP()
	local onRespSucceed = function(ipstate)
		gt.LoginServer.ip = ipstate:getIP()
		gt.LoginServer.port = gt.DefineLoginServer.port
		self:sendRealLogin( self.accessToken, self.refreshToken, self.openid, self.sex, self.nickname, self.headimgurl, self.unionid)
	end
	local onRespFailed = function(ipstate) end
	gt.socketClient:getSecureIP(self.unionid, onRespSucceed, onRespFailed)
end

return LoginScene

